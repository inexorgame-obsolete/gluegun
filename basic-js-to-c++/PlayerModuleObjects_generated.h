// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PLAYERMODULEOBJECTS_PLAYERMODULE_H_
#define FLATBUFFERS_GENERATED_PLAYERMODULEOBJECTS_PLAYERMODULE_H_

#include "flatbuffers/flatbuffers.h"

#include "DistributedStateAddress_generated.h"
#include "PlayerBuffer_generated.h"

namespace PlayerModule {

struct Change;

struct NewEntry;

struct RemoveEntry;

struct OneMessage;

/// The list of all message object types in this module.
enum Any {
  Any_NONE = 0,
  Any_PlayerBuffer = 1,
  Any_MIN = Any_NONE,
  Any_MAX = Any_PlayerBuffer
};

inline const Any (&EnumValuesAny())[2] {
  static const Any values[] = {
    Any_NONE,
    Any_PlayerBuffer
  };
  return values;
}

inline const char * const *EnumNamesAny() {
  static const char * const names[] = {
    "NONE",
    "PlayerBuffer",
    nullptr
  };
  return names;
}

inline const char *EnumNameAny(Any e) {
  if (e < Any_NONE || e > Any_PlayerBuffer) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesAny()[index];
}

template<typename T> struct AnyTraits {
  static const Any enum_value = Any_NONE;
};

template<> struct AnyTraits<PlayerBuffer> {
  static const Any enum_value = Any_PlayerBuffer;
};

bool VerifyAny(flatbuffers::Verifier &verifier, const void *obj, Any type);
bool VerifyAnyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

/// A message containing the kind of a message.
enum AnyMessageKind {
  AnyMessageKind_NONE = 0,
  AnyMessageKind_Change = 1,
  AnyMessageKind_NewEntry = 2,
  AnyMessageKind_RemoveEntry = 3,
  AnyMessageKind_MIN = AnyMessageKind_NONE,
  AnyMessageKind_MAX = AnyMessageKind_RemoveEntry
};

inline const AnyMessageKind (&EnumValuesAnyMessageKind())[4] {
  static const AnyMessageKind values[] = {
    AnyMessageKind_NONE,
    AnyMessageKind_Change,
    AnyMessageKind_NewEntry,
    AnyMessageKind_RemoveEntry
  };
  return values;
}

inline const char * const *EnumNamesAnyMessageKind() {
  static const char * const names[] = {
    "NONE",
    "Change",
    "NewEntry",
    "RemoveEntry",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnyMessageKind(AnyMessageKind e) {
  if (e < AnyMessageKind_NONE || e > AnyMessageKind_RemoveEntry) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesAnyMessageKind()[index];
}

template<typename T> struct AnyMessageKindTraits {
  static const AnyMessageKind enum_value = AnyMessageKind_NONE;
};

template<> struct AnyMessageKindTraits<Change> {
  static const AnyMessageKind enum_value = AnyMessageKind_Change;
};

template<> struct AnyMessageKindTraits<NewEntry> {
  static const AnyMessageKind enum_value = AnyMessageKind_NewEntry;
};

template<> struct AnyMessageKindTraits<RemoveEntry> {
  static const AnyMessageKind enum_value = AnyMessageKind_RemoveEntry;
};

bool VerifyAnyMessageKind(flatbuffers::Verifier &verifier, const void *obj, AnyMessageKind type);
bool VerifyAnyMessageKindVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Change FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHANGE_SET_TYPE = 4,
    VT_CHANGE_SET = 6
  };
  Any change_set_type() const {
    return static_cast<Any>(GetField<uint8_t>(VT_CHANGE_SET_TYPE, 0));
  }
  const void *change_set() const {
    return GetPointer<const void *>(VT_CHANGE_SET);
  }
  template<typename T> const T *change_set_as() const;
  const PlayerBuffer *change_set_as_PlayerBuffer() const {
    return change_set_type() == Any_PlayerBuffer ? static_cast<const PlayerBuffer *>(change_set()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CHANGE_SET_TYPE) &&
           VerifyOffset(verifier, VT_CHANGE_SET) &&
           VerifyAny(verifier, change_set(), change_set_type()) &&
           verifier.EndTable();
  }
};

template<> inline const PlayerBuffer *Change::change_set_as<PlayerBuffer>() const {
  return change_set_as_PlayerBuffer();
}

struct ChangeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_change_set_type(Any change_set_type) {
    fbb_.AddElement<uint8_t>(Change::VT_CHANGE_SET_TYPE, static_cast<uint8_t>(change_set_type), 0);
  }
  void add_change_set(flatbuffers::Offset<void> change_set) {
    fbb_.AddOffset(Change::VT_CHANGE_SET, change_set);
  }
  explicit ChangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChangeBuilder &operator=(const ChangeBuilder &);
  flatbuffers::Offset<Change> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Change>(end);
    return o;
  }
};

inline flatbuffers::Offset<Change> CreateChange(
    flatbuffers::FlatBufferBuilder &_fbb,
    Any change_set_type = Any_NONE,
    flatbuffers::Offset<void> change_set = 0) {
  ChangeBuilder builder_(_fbb);
  builder_.add_change_set(change_set);
  builder_.add_change_set_type(change_set_type);
  return builder_.Finish();
}

struct NewEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTRY_ADDRESS = 4,
    VT_INITIAL_STATE_TYPE = 6,
    VT_INITIAL_STATE = 8
  };
  const distributed_state::Address *entry_address() const {
    return GetPointer<const distributed_state::Address *>(VT_ENTRY_ADDRESS);
  }
  Any initial_state_type() const {
    return static_cast<Any>(GetField<uint8_t>(VT_INITIAL_STATE_TYPE, 0));
  }
  const void *initial_state() const {
    return GetPointer<const void *>(VT_INITIAL_STATE);
  }
  template<typename T> const T *initial_state_as() const;
  const PlayerBuffer *initial_state_as_PlayerBuffer() const {
    return initial_state_type() == Any_PlayerBuffer ? static_cast<const PlayerBuffer *>(initial_state()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTRY_ADDRESS) &&
           verifier.VerifyTable(entry_address()) &&
           VerifyField<uint8_t>(verifier, VT_INITIAL_STATE_TYPE) &&
           VerifyOffset(verifier, VT_INITIAL_STATE) &&
           VerifyAny(verifier, initial_state(), initial_state_type()) &&
           verifier.EndTable();
  }
};

template<> inline const PlayerBuffer *NewEntry::initial_state_as<PlayerBuffer>() const {
  return initial_state_as_PlayerBuffer();
}

struct NewEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entry_address(flatbuffers::Offset<distributed_state::Address> entry_address) {
    fbb_.AddOffset(NewEntry::VT_ENTRY_ADDRESS, entry_address);
  }
  void add_initial_state_type(Any initial_state_type) {
    fbb_.AddElement<uint8_t>(NewEntry::VT_INITIAL_STATE_TYPE, static_cast<uint8_t>(initial_state_type), 0);
  }
  void add_initial_state(flatbuffers::Offset<void> initial_state) {
    fbb_.AddOffset(NewEntry::VT_INITIAL_STATE, initial_state);
  }
  explicit NewEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NewEntryBuilder &operator=(const NewEntryBuilder &);
  flatbuffers::Offset<NewEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NewEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<NewEntry> CreateNewEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<distributed_state::Address> entry_address = 0,
    Any initial_state_type = Any_NONE,
    flatbuffers::Offset<void> initial_state = 0) {
  NewEntryBuilder builder_(_fbb);
  builder_.add_initial_state(initial_state);
  builder_.add_entry_address(entry_address);
  builder_.add_initial_state_type(initial_state_type);
  return builder_.Finish();
}

struct RemoveEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RemoveEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RemoveEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemoveEntryBuilder &operator=(const RemoveEntryBuilder &);
  flatbuffers::Offset<RemoveEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RemoveEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<RemoveEntry> CreateRemoveEntry(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RemoveEntryBuilder builder_(_fbb);
  return builder_.Finish();
}

struct OneMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODULE_INFO_TYPE = 4,
    VT_MODULE_INFO = 6
  };
  AnyMessageKind module_info_type() const {
    return static_cast<AnyMessageKind>(GetField<uint8_t>(VT_MODULE_INFO_TYPE, 0));
  }
  const void *module_info() const {
    return GetPointer<const void *>(VT_MODULE_INFO);
  }
  template<typename T> const T *module_info_as() const;
  const Change *module_info_as_Change() const {
    return module_info_type() == AnyMessageKind_Change ? static_cast<const Change *>(module_info()) : nullptr;
  }
  const NewEntry *module_info_as_NewEntry() const {
    return module_info_type() == AnyMessageKind_NewEntry ? static_cast<const NewEntry *>(module_info()) : nullptr;
  }
  const RemoveEntry *module_info_as_RemoveEntry() const {
    return module_info_type() == AnyMessageKind_RemoveEntry ? static_cast<const RemoveEntry *>(module_info()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MODULE_INFO_TYPE) &&
           VerifyOffset(verifier, VT_MODULE_INFO) &&
           VerifyAnyMessageKind(verifier, module_info(), module_info_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Change *OneMessage::module_info_as<Change>() const {
  return module_info_as_Change();
}

template<> inline const NewEntry *OneMessage::module_info_as<NewEntry>() const {
  return module_info_as_NewEntry();
}

template<> inline const RemoveEntry *OneMessage::module_info_as<RemoveEntry>() const {
  return module_info_as_RemoveEntry();
}

struct OneMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_module_info_type(AnyMessageKind module_info_type) {
    fbb_.AddElement<uint8_t>(OneMessage::VT_MODULE_INFO_TYPE, static_cast<uint8_t>(module_info_type), 0);
  }
  void add_module_info(flatbuffers::Offset<void> module_info) {
    fbb_.AddOffset(OneMessage::VT_MODULE_INFO, module_info);
  }
  explicit OneMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OneMessageBuilder &operator=(const OneMessageBuilder &);
  flatbuffers::Offset<OneMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OneMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<OneMessage> CreateOneMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    AnyMessageKind module_info_type = AnyMessageKind_NONE,
    flatbuffers::Offset<void> module_info = 0) {
  OneMessageBuilder builder_(_fbb);
  builder_.add_module_info(module_info);
  builder_.add_module_info_type(module_info_type);
  return builder_.Finish();
}

inline bool VerifyAny(flatbuffers::Verifier &verifier, const void *obj, Any type) {
  switch (type) {
    case Any_NONE: {
      return true;
    }
    case Any_PlayerBuffer: {
      auto ptr = reinterpret_cast<const PlayerBuffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyAnyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAny(
        verifier,  values->Get(i), types->GetEnum<Any>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyAnyMessageKind(flatbuffers::Verifier &verifier, const void *obj, AnyMessageKind type) {
  switch (type) {
    case AnyMessageKind_NONE: {
      return true;
    }
    case AnyMessageKind_Change: {
      auto ptr = reinterpret_cast<const Change *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyMessageKind_NewEntry: {
      auto ptr = reinterpret_cast<const NewEntry *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyMessageKind_RemoveEntry: {
      auto ptr = reinterpret_cast<const RemoveEntry *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyAnyMessageKindVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnyMessageKind(
        verifier,  values->Get(i), types->GetEnum<AnyMessageKind>(i))) {
      return false;
    }
  }
  return true;
}

inline const PlayerModule::OneMessage *GetOneMessage(const void *buf) {
  return flatbuffers::GetRoot<PlayerModule::OneMessage>(buf);
}

inline const PlayerModule::OneMessage *GetSizePrefixedOneMessage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<PlayerModule::OneMessage>(buf);
}

inline bool VerifyOneMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<PlayerModule::OneMessage>(nullptr);
}

inline bool VerifySizePrefixedOneMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<PlayerModule::OneMessage>(nullptr);
}

inline void FinishOneMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<PlayerModule::OneMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedOneMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<PlayerModule::OneMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace PlayerModule

#endif  // FLATBUFFERS_GENERATED_PLAYERMODULEOBJECTS_PLAYERMODULE_H_
